# goit-algo-hw-10

# Порівняння алгоритмів видачі решти

## Опис задачі
Розроблено систему для касового апарату, яка визначає оптимальний спосіб видачі решти покупцеві, використовуючи набір монет `[50, 25, 10, 5, 2, 1]`.

## Реалізовані алгоритми

### 1. Жадібний алгоритм (`find_coins_greedy`)
**Принцип роботи:** На кожному кроці вибирає максимально можливу кількість монет найбільшого доступного номіналу.

**Переваги:**
- Простота реалізації
- Швидка робота - O(n), де n - кількість номіналів
- Мінімальне використання пам'яті - O(1)
- Ефективний для систем монет з "канонічними" номіналами

**Недоліки:**
- Не завжди дає оптимальний результат
- Може використати більше монет, ніж необхідно

### 2. Динамічне програмування (`find_min_coins`)
**Принцип роботи:** Будує таблицю оптимальних рішень для всіх сум від 0 до цільової, використовуючи раніше обчислені результати.

**Переваги:**
- Завжди знаходить оптимальне рішення
- Гарантує мінімальну кількість монет
- Працює з будь-якими системами номіналів

**Недоліки:**
- Складність O(m×n), де m - сума, n - кількість номіналів
- Потребує O(m) додаткової пам'яті
- Повільніший за жадібний алгоритм

## Результати тестування

### Коректність роботи
Для суми **113**:
- **Жадібний алгоритм:** `{50: 2, 10: 1, 2: 1, 1: 1}` - всього 5 монет
- **Динамічне програмування:** `{50: 2, 10: 1, 2: 1, 1: 1}` - всього 5 монет

Обидва алгоритми дають однаковий результат для цієї суми.

### Аналіз продуктивності

#### Часова складність:
| Алгоритм | Складність | Залежність від |
|----------|-----------|----------------|
| Жадібний | O(n) | Кількості номіналів |
| ДП | O(m×n) | Суми та кількості номіналів |

#### Просторова складність:
| Алгоритм | Складність | Використання пам'яті |
|----------|-----------|---------------------|
| Жадібний | O(1) | Константна |
| ДП | O(m) | Пропорційна сумі |

### Порівняння швидкодії

На основі тестування для сум від 50 до 2000:

| Діапазон суми | Жадібний (мс) | ДП (мс) | Співвідношення |
|---------------|---------------|---------|----------------|
| 50-500 | ~0.002 | ~0.05 | ДП повільніший у 25x |
| 500-1000 | ~0.002 | ~0.10 | ДП повільніший у 50x |
| 1000-2000 | ~0.002 | ~0.20 | ДП повільніший у 100x |

## Коли краще використовувати кожен алгоритм

### Жадібний алгоритм:
1. **Швидкість критична** - для real-time систем (касові апарати, вендингові автомати)
2. **Великі суми** - при роботі з сумами > 1000
3. **Канонічна система монет** - номінали утворюють систему, де жадібний алгоритм гарантовано оптимальний
4. **Обмежені ресурси** - на вбудованих системах з обмеженою пам'яттю

### Динамічне програмування:
1. **Оптимальність важливіша за швидкість** - банківські системи, фінансові розрахунки
2. **Нестандартні номінали** - наприклад, [1, 3, 4] де жадібний дасть неоптимальний результат
3. **Малі суми** - для сум < 100 різниця в швидкості незначна
4. **Аналітичні задачі** - дослідження оптимальних систем номіналів

## Приклад неоптимальності жадібного алгоритму

Для системи монет `[1, 3, 4]` та суми `6`:
- **Жадібний:** `{4: 1, 1: 2}` - 3 монети
- **ДП:** `{3: 2}` - 2 монети (оптимально)

## Висновки

1. **Для системи монет** `[50, 25, 10, 5, 2, 1]` жадібний алгоритм часто дає оптимальний або близький до оптимального результат.

2. **Жадібний алгоритм** виграє за швидкістю в 25-100 разів залежно від суми, що робить його ідеальним для повсякденного використання в касових апаратах.

3. **Динамічне програмування** гарантує оптимальність, але його використання виправдане лише для:
   - Критично важливих фінансових операцій
   - Систем з нестандартними номіналами
   - Аналітичних та дослідницьких задач

## Оптимізації для великих сум

### Для жадібного алгоритму:
- Попереднє сортування номіналів (вже реалізовано)
- Використання бінарного пошуку для великої кількості номіналів

### Для динамічного програмування:
- Мемоізація для повторюваних обчислень
- Обмеження максимальної суми для обробки
- Використання жадібного алгоритму як евристики для попередньої оцінки

## Практичне застосування

Для реальної касової системи рекомендується гібридний підхід:
```python
def smart_change(amount, coins):
    if amount > 1000:  # Для великих сум
        return find_coins_greedy(amount, coins)
    else:  # Для малих сум
        return find_min_coins(amount, coins)
```

Це забезпечує оптимальний баланс між швидкістю та точністю.